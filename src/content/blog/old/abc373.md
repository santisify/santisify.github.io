---
title: 'Atcoder beginner contest 373'
tags: [ '题解', 'atcoder' ]
publishDate: '2024-08-25 19:30:34'
description: 'Atcoder abc 373(A-C)'
heroImage: { src: './ACGN/5.webp', color: '#4891B2' }
language: 'zh-cn'
---
# A September
 [September](https://atcoder.jp/contests/abc373/tasks/abc373_a)
## 题目描述
{% tabs A %}
<!-- tab 英文题面-->
There are $12$ strings $S_1, S_2, \ldots, S_{12}$ consisting of lowercase English letters.

Find how many integers $i$ $(1 \leq i \leq 12)$ satisfy that the length of $S_i$ is $i$.
<!-- endtab -->

<!-- tab 中文题面 -->
有 $12$ 个字符串 $S_1, S_2, S_3, \cdots S_{12}$
问有几个字符串满足 $S_{i} = i (1 \le i \le 12)$ 
<!-- endtab -->
{% endtabs %}
> 太简单不需要解释
## 参考代码

```cpp
#include<bits/stdc++.h>

#define int long long
#define endl '\n'
#define pii std::pair<int ,int>
#define fix(x) std::fixed << std::setprecision(x)
const int inf = 1e17 + 50, MAX_N = 1e5 + 50, mod = 1e9 + 7;

void solve() {
	int ct = 0;
	for(int i = 0; i < 12; i++) {
		std::string s;
		std::cin >> s;
		if (s.size() == i + 1) ct++;
	}
	std::cout << ct << endl;
}

signed main() {
	std::ios::sync_with_stdio(false);
	std::cin.tie(nullptr), std::cout.tie(nullptr);
	solve();
	return 0;
}
```

# B 1D Keyboard
[1D Keyboard](https://atcoder.jp/contests/abc373/tasks/abc373_b)
## 题目描述
{% tabs B %}
<!-- tab 英文题面-->
### Problem Statement

There is a keyboard with $26$ keys arranged on a number line.

The arrangement of this keyboard is represented by a string $S$, which is a permutation of `ABCDEFGHIJKLMNOPQRSTUVWXYZ`. The key corresponding to the character $S_x$ is located at coordinate $x$ $(1 \leq x \leq 26)$. Here, $S_x$ denotes the $x$\-th character of $S$.

You will use this keyboard to input `ABCDEFGHIJKLMNOPQRSTUVWXYZ` in this order, typing each letter exactly once with your right index finger. To input a character, you need to move your finger to the coordinate of the key corresponding to that character and press the key.

Initially, your finger is at the coordinate of the key corresponding to `A`. Find the minimal possible total traveled distance of your finger from pressing the key for `A` to pressing the key for `Z`. Here, pressing a key does not contribute to the distance.
<!-- endtab -->

<!-- tab 中文题面 -->
给定长度为 $26$ 的字符串，并且保证字符串每个英文字母只出现一次,当前第 $0$ 步时处于 $A$ 点, 问需要走多少步会使得字符串所走过的路径为 $ABC.....XYZ$.简单点说就是从 $A$ 点走到 $B$ 点,再到 $C$ 点,以此类推,知道 $Z$ 点,至少需要走多少步?
<!-- endtab -->
{% endtabs %}

## 解题思路
> 由于字符串中一个字母只会出现一次,我们就可以将每个字母的位置记录下来,然后再依次算出相邻两个点的距离,即可得出答案.

## 参考代码

```cpp
#include<bits/stdc++.h>

#define int long long
#define endl '\n'
#define pii std::pair<int ,int>
#define fix(x) std::fixed << std::setprecision(x)
const int inf = 1e17 + 50, MAX_N = 1e5 + 50, mod = 1e9 + 7;

void solve() {
	std::string s;
	std::cin >> s;

	std::map<char, int> mp;
	for(int i = 0; i < s.size(); i++) {
		mp[s[i]] = i;
	}
	int now = mp['A'];
	int w = 0;
	mp.erase('A');
	for(auto [c, pos] : mp) {
		w += abs(now - pos);
		now = pos;
	}

	std::cout << w << endl;
}

signed main() {
	std::ios::sync_with_stdio(false);
	std::cin.tie(nullptr), std::cout.tie(nullptr);
	solve();
	return 0;
}
```

# C Max Ai+Bj
[Max Ai+Bj](https://atcoder.jp/contests/abc373/tasks/abc373_c)
## 题目描述
{% tabs C %}
<!-- tab 英文题面 -->
### Problem Statement
You are given two integer sequences $A$ and $B$, each of length $N$. Choose integers $i, j$ $(1 \leq i, j \leq N)$ to maximize the value of $A_i + B_j$.
<!-- endtab -->

<!-- tab 中文题面 -->
#### 问题陈述

给你两个整数序列 $A$ 和 $B$ ，每个长度为 $N$ 。请选择整数 $i, j$ $(1 \leq i, j \leq N)$ 使其长度最大化。 $(1 \leq i, j \leq N)$ 使 $A _{i} + B_{j}$ 的值最大。输出最大值。
<!-- endtab -->
{% endtabs %}

## 解题思路
> 选择尽量大的 $i,j$ 使得 $A_{i} + B_{j}$最大,为了使得和最大,只需要分别选择两个数组的最大值，才能使得和最大。

## 参考代码

```cpp
#include<bits/stdc++.h>

#define int long long
#define endl '\n'
#define pii std::pair<int ,int>
#define fix(x) std::fixed << std::setprecision(x)
const int inf = 1e17 + 50, MAX_N = 1e5 + 50, mod = 1e9 + 7;

void solve() {
	int n;
	std::cin >> n;
	std::vector<int> a(n), b(n);

	for(int i = 0, x; i < n; i++) {
		std::cin >> a[i];
	}
	for(int i = 0, x; i < n; i++) {
		std::cin >> b[i];
	}
	std::sort(a.begin(), a.end());
	std::sort(b.begin(), b.end());
	std::cout << a[n - 1] + b[n - 1] << endl;
}

signed main() {
	std::ios::sync_with_stdio(false);
	std::cin.tie(nullptr), std::cout.tie(nullptr);
	solve();
	return 0;
}
```
